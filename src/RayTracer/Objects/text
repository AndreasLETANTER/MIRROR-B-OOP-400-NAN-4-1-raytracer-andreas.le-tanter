// cone infini

// bool RayTracer::Cone::hits(Ray& t_ray)
// {
//     Math::Vector3D OC = t_ray.m_origin - c_apex;
//     float a = pow(t_ray.m_direction.m_x_component, 2)
//     + pow(t_ray.m_direction.m_y_component, 2)
//     - pow(t_ray.m_direction.m_z_component, 2) * pow(c_slope, 2);
//     float b = 2 * (t_ray.m_direction.m_x_component
//     * OC.m_x_component + t_ray.m_direction.m_y_component
//     * OC.m_y_component - t_ray.m_direction.m_z_component
//     * * OC.m_z_component * pow(c_slope, 2));
//     float c = pow(OC.m_x_component, 2) + pow(OC.m_y_component, 2)
//     - pow(OC.m_z_component, 2) * pow(c_slope, 2);
//     float discriminant = pow(b, 2) - 4 * a * c;

//     if (discriminant <= 0) {
//         return false;
//     }
//     double t1 = (-b - sqrt(discriminant)) / (2.0 * a);
//     double t2 = (-b + sqrt(discriminant)) / (2.0 * a);
//     double t;
//     if (t1 > 0) {
//         t = t1;
//     } else if (t2 > 0) {
//         t = t2;
//     } else {
//         return false;
//     }
//     m_hit_point = t_ray.m_origin + t_ray.m_direction * t;
//     return true;
// }


// cone fini
// bool RayTracer::Cone::hits(Ray& t_ray)
// {
//     Math::Vector3D OC = t_ray.m_origin - c_apex;
//     float a = pow(t_ray.m_direction.m_x_component, 2) + pow(t_ray.m_direction.m_y_component, 2) - pow(t_ray.m_direction.m_z_component, 2) * pow(c_slope, 2);
//     float b = 2 * (t_ray.m_direction.m_x_component * OC.m_x_component + t_ray.m_direction.m_y_component * OC.m_y_component - t_ray.m_direction.m_z_component * OC.m_z_component * pow(c_slope, 2));
//     float c = pow(OC.m_x_component, 2) + pow(OC.m_y_component, 2) - pow(OC.m_z_component, 2) * pow(c_slope, 2);
//     float discriminant = pow(b, 2) - 4 * a * c;

//     if (discriminant <= 0) {
//         return false;
//     }
//     double t1 = (-b - sqrt(discriminant)) / (2.0 * a);
//     double t2 = (-b + sqrt(discriminant)) / (2.0 * a);
//     double t;
//     if (t1 > 0 && isWithinHeightRange(t1)) {
//         t = t1;
//     } else if (t2 > 0 && isWithinHeightRange(t2)) {
//         t = t2;
//     } else {
//         return false;
//     }
//     m_hit_point = t_ray.m_origin + t_ray.m_direction * t;
//     return true;
// }

// bool RayTracer::Cone::isWithinHeightRange(double t)
// {
//     Math::Vector3D intersectionPoint = t_ray.m_origin + t_ray.m_direction * t;
//     double height = intersectionPoint.m_y_component - c_apex.m_y_component;
//     return (height >= 0 && height <= c_height);
// }


// cylindre fini calcul matricielle
// bool RayTracer::Cylinder::hits(Ray& t_ray)
// {
//     double **tab = (double **)malloc(sizeof(double) * 4);
//     double angle = 70.0;
//     double ratio = 1.0;
//     double near = -4.0;
//     double far = 200000000;
//     double o[] = {t_ray.m_origin.m_x_component, t_ray.m_origin.m_y_component
//     , t_ray.m_origin.m_z_component,};
//     double d[] = {t_ray.m_direction.m_x_component, t_ray.m_direction.m_y_component
//     , t_ray.m_direction.m_z_component};

//     for (int i = 0; i < 4; i++) {
//         tab[i] = (double *)malloc(sizeof(double) * 4);
//         for (int j = 0; j < 4; j++) {
//             tab[i][j] = 0.0;
//         }
//     }
//     tab[0][0] = (1 / (ratio * tan(angle / 2)));
//     tab[1][1] = (1 / (tan(angle / 2)));
//     tab[2][2] = ((near + far) / (near - far));
//     tab[2][3] = (2 * near + far) / (near - far);
//     tab[3][2] = -1;
//     float a = tab[0][0] * pow(d[0], 2) + 2 * tab[0][1] * d[0] * d[1]
//     + 2 * tab[0][2] * d[0] * d[2] + tab[1][1] * pow(d[1], 2)
//     + 2 * tab[1][2] * d[1] * d[2] + tab[2][2] * pow(d[2], 2);
//     float b = 2 * (tab[0][0] * o[0] * d[0]
//     + tab[0][1] * (o[0] * d[1] + d[0] * o[1])
//     + tab[0][2] * (o[0] * d[2] + d[0] * o[2])
//     + tab[0][3] * d[0] + tab[1][1] * o[1] * o[1] * d[1]
//     + tab[1][2] * (o[1] * d[2] + d[1] * o[2])
//     + tab[1][3] * (d[1]) + tab[2][2] * o[2] * d[2] + tab[2][3] * d[2]);
//     float c = tab[0][0] * pow(o[0], 2) + 2 * tab[0][1] * o[0] * o[1]
//     + 2 * tab[0][2] * (o[0] * o[2] + 2 * tab[0][3] * o[0]
//     + tab[1][1] * o[1] + 2 * tab[1][2] * o[1] * o[2]
//     + 2 * tab[1][3] * o[1] + tab[2][2] * pow(o[2], 2) + 2 * tab[2][3] * o[2]
//     + tab[3][3]);
//     float discriminant = pow(b, 2) - 4 * a * c;
//     const double t = (-b - sqrt(discriminant)) / (2.0 * a);
//     if (discriminant <= 0) {
//         return (false);
//     }
//     m_hit_point = t_ray.m_origin + t_ray.m_direction * abs(t);
//     return (true);
// }